#+Title: Linux Foundation Course
#+Author: Yogesh Agrawal
#+Date: <2016-03-19 Sat>
#+Email: yogeshiiith@gmail.com

* Introduction
  This document has the learning which I learn from the Linux
  Foundation Course: LFS101x in edx.

* Linux requirements
  The technical differences are mainly about package management
  systems, software versions, and file locations.
** Key facts about Debian Family
  - The Debian family is upstream for Ubuntu.
  - The Linux Kernel 3.13 is used in Ubuntu 14.04
  - It uses the DPKG-based apt-get package manager to install, update,
    and remove packages in the system.

** Key facts about Fedora Family
  - The fedora family is upstream for CentOS, RHEL, and Oracle Linux.
  - The Linux kernel 2.6.32 is used in RHEL/CentOS 6.x
  - It uses the RPM-based yum package manager to install, update and
    remove packages in the system.

* Linux philosophy
  Linux is derived heavily from UNIX operating system. Files are
  organized in a hierarchical filesystem, with the top node of the
  system being root or =/=. Linux components are made available via
  files or objects that look like files. Processes, devices and
  network sockets are all represented by file-like objects, and can
  often be worked with same utilities used for regular files.

  Linux is a multiuser and multitasking operating system, with built
  in networking and service processes known as daemons in the UNIX
  world.

* Linux terminology
** Kernel
  Kernel is the brain of the Operating System. It controls the
  hardware and make hardware available for applications. Latest Linux
  kernel can be seen from http:://kernel.org site.

** Distribution
  Distribution is the bunch of programs combined together with Linux
  kernel to make a Linux based Operating System. Example are Fedora
  and Debian.

** Boot Loader
  Program that boots the operating system. Example are GRUB and
  ISOLinux.

** Service
  Service is a program that runs as a background process. Example
  httpd, nfsd, ftpd and named.

** Filesystem
  Method for storing and organizing files. Example are ntfs, ext3,
  ext4, FAT, NTFS.

** X Windows System
  Provides toolkit or protocol to build graphical interfaces in nearly
  all Linux system.

** Desktop Environment
  Graphical user interface on top of Linux operating system. Example
  are GNOME and KDE.

** Command Line
  Interface for typing commands on top of the operating system.

** Shell
  Command line interpreter that interprets the command line input and
  instructs the operating system to perform any necessary tasks and
  commands. Example are bash and zshell.
 
* Partitions and Filesystems
  Partition is a logical part of the disk, whereas filesystem is a
  method of storing/finding files on a hard disk. You can think of
  filesystems as being like a family tree and partitions as different
  families each of which as its own tree.

* Filesystem hierarchy standard
  Linux filesystem names are case sensitive, that means =/boot=, =/Boot=
  and =/BOOT= represent three different directories. Many distributions
  distinguish between core utilities needed for proper system operation
  and other programs. So other programs are placed inside =/usr=
  directory. Example of directories inside =/= root directory.
  #+BEGIN_EXAMPLE
  .
  |-- bin
  |-- boot
  |-- cdrom
  |-- dev
  |-- etc
  |-- home
  |-- lib
  |-- lib64
  |-- lost+found
  |-- media
  |-- mnt
  |-- opt
  |-- proc
  |-- root
  |-- run
  |-- sbin
  |-- srv
  |-- sys
  |-- tmp
  |-- usr
  `-- var
  #+END_EXAMPLE

* The Boot Process
  - Boot process is the procedure of initializing the system.

  - Understanding boot process will help in troubleshooting systems
    issues more elegantly.

  - The boot process consists of following 9 steps:
    #+BEGIN_EXAMPLE
    1. Power On
    2. BIOS
    3. MBR - Master Boot Record
    4. Boot Loader
    5. Kernel OS
    6. Init Ramfs
    7. /sbin/init
    8. Shell
    9. Graphics
    #+END_EXAMPLE

** BIOS
  Basic Input/Output System initializes the hardware, including the
  screen and keyboard, and tests the main memory. The BIOS software is
  stored on ROM chip on motherboard. After this the remainder of the
  boot process is completely controlled by the operating system.

** Master boot record
  Searches for the boot loader and loads into the RAM.

** Boot Loader
  Boot loader is stored on the boot sector. Boot loaders present a
  user interface for user to choose from available option of operating
  systems. Boot loader is responsible for loading kernel image and the
  initial RAM disk (which contains some critical files and device
  drivers needed to start the system) into memory.

*** Boot loader in action
    The boot loader resides at the first sector of the hard disk also
    known as the Master Boot Record (MBR). The size of the MBR is just
    512 bytes. Boot loader first finds the bootable partition. Once it
    finds the bootable partition it then searches for the second level
    boot loader - GRUB. It then loads the grub into the main memory.
    
    Boot loader displays options which allows us to choose different
    available operating systems. After choosing the operating system
    boot loader loads the kernel into the main memory and passes
    control to it.
    
    Kernel are always compressed when loaded into main memory so its
    first job is to uncompress itself. After this it will check and
    analyze the system hardware and initialize any hardware device
    driver built into the kernel.

** Linux Kernel
  The boot loader loads the kernel and initial ram file system in the
  main memory. Kernel initializes all hardware systems attached to the
  machine this includes all processors, I/O systems, storage devices
  etc. Kernel also loads some necessary user level applications into
  the main memory.

** /sbin/init process
  Once the kernel has setup all the hardware and mounted the root file
  system, the kernel runs the =/sbin/init= program.
  
  init is responsible for keeping the system running and shutting
  down. It is responsible for all non-kernel processes, cleaning up
  after them when necessary, and restarts user login services as
  needed when using log in and out.

** X Windows system
  We can start the default display manager after logging on to a
  text-mode console, and running *startx* from the command line.

* Linux Installation
** Choosing Distribution
  Questions that are to be asked while choosing Linux distributions:
  - What is the main purpose of the OS, server or desktop ?
  - How much disk space is available ?
  - How often packages are updated in a particular distribution ?
  - What is the architecture of the hardware ?

** Partition
  Decide how you want to partition the disk to install OS. You may
  choose to have separate partition for =/home=, =/var= and =/root=.

** Source of installation
  - optical disk: cd, dvds
  - usb
  - network boot

** Automating installation
  Installation process can be automated using a configuration file
  specifying the installation options. For debian-based system file is
  called =preseed=. Example preseed file is here hosted on internet by
  help-ubuntu community:
  https://help.ubuntu.com/lts/installation-guide/example-preseed.txt

** Restart, sleep and shutdown
  - System asks for confirmation while shutting down because many
    applications do not save their data properly when terminated while
    running.

  - Sleep mode works by keeping the applications, desktop and so on in
    RAM and turning off all other hardware.

* Gnome desktop environment
  - Gnome is popular desktop environment and graphical user interface
    that runs on top of the Linux operating system.
  - Ubuntu has =unity= desktop manager which is based on gnome.
  - "Nautilus" is the file browser in gnome.
  - File manager shows following default directories:
    + HOME directory :: User's home directory
    + Computer :: Different drives attached to the system such as hard
                  disk drives, cd/dvd, usb pendrives etc.
    + Network :: Networked and shared devices such as Network shares,
                 printers and file servers.
  - Removing a file, moves the file to trash folder. Trash folder is
    located at =~/.local/share/Trash/files/=.
  - Logging out kills all processes in your current *X* session and
    returns to the display manager.

* System configuration using graphical interface
** Display settings
  Default configuration is to show a large big screen spanning all the
  monitors. We can change this to display same screen in all the
  monitors by =mirroring=.

** Data and time settings
  Linux always uses UTC (Coordinated Universal Time) for its internal
  time settings.

** Network time protocol (NTP)
  NTP is the most popular and reliable protocol for setting local time
  from internet servers. Linux can set the system's local time by
  referring to specific time servers run by distribution.

** Network Configuration
  All Linux distributions have configuration files for managing
  network. File formats and locations can differ from one distribution
  to another. Hand editing these files can handle complicated
  setup. For simple configuration *Network Manager* tool was
  designed. It can lists all available networks (both wired and
  wireless), allow the choice of a wired, wireless or mobile broadband
  network, handle passwords and set vpn. Network manager establishes
  the connections and keep track of your settings.

  The hardware interface and presence of signal is automatically
  detected and then network manager sets the actual network settings
  via *DHCP*. Static configuration can also be done via network
  manager.

  Network manager can manage vpn connections also. It supports many
  VPN technologies such as IPSec.
  
* Linux Documentation Sources
** Man pages
  man stands for manual pages. man program searches, formats and
  displays the information contained in the man pages. Many topics
  have a lot of information, output is piped through a terminal pager
  (less) program such as less to be viewed one page at a time.

  man pages provide in-depth documentation about programs and other
  topics about the system including configuration files, system calls,
  library routines, and the kernel.

  man pages are organized together in the form of 9 chapters. The
  chapter number can be used to force man to display the page from a
  particular chapter.

  - man -f :: searches for man pages containing a string in
              them. generates the result as typing *whatis*
  - man -k :: view all man pages that discuss a specified
              subject. generates the same result as typing *apropos*
  - man -a :: man will display all pages with the given name in all
              chapters, one after the other.

** gnu info
  we can use =info <topic-name>= to information about the topic.

** help
  =topic -h= or =topic --help= are used for quick reference.  =help=
  display a short synopsis of built-in shell commands.

** Desktop help
  we can start the desktop help system from a graphical terminal using
  the =gnome-help= command.

** Package documentation
  This documentation is directly pulled from the upstream source code.
  It can also contain information about how the distribution is
  packaged and set up the software. Such information is placed under
  the =/usr/share/doc= directory in a subdirectory named after the
  package, perhaps including the version number in the name.

** Online resources
  - https://www.centos.org/docs/ (centos documentation)
  - http://linuxcommand.org/tlcl.php (Linux command help)

* Command line operations
** X Windows system
  The customizable nature of Linux allows you to drop (temporarily or
  permanently) the X windows graphical interface, or to start it up
  after the system has been running.

  Linux production servers are usually installed without X and even if
  it is installed, usually do not launch it during start up. Removing
  X from a production server can be very helpful in maintaining a lean
  system which can be easier to support and keep secure.

** Virtual Terminals
  Virtual terminals are console sessions that use entire display and
  keyboard outside of a graphical environment. Such terminals are
  considered "virtual" because it is not same as command line terminal
  window. Although you can have multiple active terminals, only one
  terminal remains visible at a time.

  Example situation where virtual terminal can be used is when we face
  problem with graphical interface, then we can switch to one of the
  virtual terminal and troubleshoot the problem.

  To switch between the VTs, press *ctrl-alt-corresponding function
  key* for the VT. Example: you will have to press *ctrl-alt-F6* for
  VT 6.  You only have to press *alt-F6* if you are in already in a VT
  not running X and want to switch to another VT.

** Command line
  There are three basic elements of a command line:
  - command :: actual command
  - options :: switch to the commands
  - arguments :: input over which command operates on

** Turn off graphical desktop
  In debian based system desktop manager runs as a service. We can
  stop the service at anytime. For rpm-based system the desktop
  manager is run directly by init when set to run level 5; switching
  to a different runlevel stops the desktop.

  1. In debian based system
     #+BEGIN_EXAMPLE
     sudo service lightdm stop
     sudo service gdm stop
     #+END_EXAMPLE

  2. In RPM based system
     #+BEGIN_EXAMPLE
     sudo telinit 3
     #+END_EXAMPLE

** Schedule shutdown
  Schedule system's shutdown and inform all the users logedin to the
  system.
  #+BEGIN_EXAMPLE
  shutdown -h 10:00 "Shutting down for scheduled maintenance"
  #+END_EXAMPLE

** Locating applications
  1. One way is to use which, it searches only for executables.
     #+BEGIN_EXAMPLE
     $ which apt-get 
     /usr/bin/apt-get
     #+END_EXAMPLE
  2. Another way is to use whereis. It looks for the packages in a
     broader range of system directories.
     #+BEGIN_EXAMPLE
     $ whereis apt-get
     apt-get: /usr/bin/apt-get /usr/bin/X11/apt-get /usr/share/man/man8/apt-get.8.gz
     #+END_EXAMPLE

** Stats
  Status of the file can be found using =stat= command. Links values
  shows the number of hard links the file have including itself.
  #+BEGIN_EXAMPLE
  yogesh@machine:~/projects/documents$ stat linux-foundation-course.org 
  File: 'linux-foundation-course.org'
  Size: 14462     	Blocks: 32         IO Block: 4096   regular file
  Device: 807h/2055d	Inode: 4071531     Links: 1
  Access: (0664/-rw-rw-r--)  Uid: ( 1000/  yogesh)   Gid: ( 1000/  yogesh)
  Access: 2016-04-03 10:33:40.382986825 +0530
  Modify: 2016-04-03 10:00:57.074984368 +0530
  Change: 2016-04-03 10:36:33.314987042 +0530
  Birth: -
  #+END_EXAMPLE

** Hard and Soft links
  - Soft link :: Soft link is a new file which only contains the name
                 of the original file. It has different inode number
                 than the original file. Symlinks works across the
                 filesystem. If the original file is deleted the
                 symlink will no longer be valid, however the file
                 will continue to exist.
                 #+BEGIN_EXAMPLE
                 ln -s original-file symlink
                 #+END_EXAMPLE
  - Hard link :: Hard link is a new file which points to the same
                 inode number as the original file. If original file
                 is deleted the hard link will still exist. When
                 either of the hard link or original file is modified
                 the changes are reflected in both of the files. If we
                 delete the original file, the hard link will still
                 exist. The inode will only be deleted when all the
                 links to it are deleted. Hard link does not work
                 across the filesytem. The hard link and the original
                 file has to be in the same filesystem. To create a
                 hard link use following command:
                 #+BEGIN_EXAMPLE
                 ln original-file hardlink
                 #+END_EXAMPLE
** File streams
  When a command is run, three file descriptors are open by default
  one for reading standard input (*stdin*), one for writing standard
  output (*std out*) and one for writing standard error (*std
  err*). These files are accessed via file descriptors. 

  In Linux all open files are represented by file descriptors. File
  descriptors are number starting with 0 for stdin, 1 for stdout and 2
  for stderr. If any other descriptors are open in addition to these
  default descriptors, then there numbering will start after 3.

  stdin is usually keyboard, stdout and stederr are terminal by
  default. These descriptors can be changed as per the
  requirements. For example we can make command to take input from a
  file and write to a file instead of keyboard using redirection. We
  can also send output of one command to be as the input for another
  command using pipe.

** I/O redirection
  In shell we can redirect the standard file stream so that we can get
  input from a file, or from keyboard. We can redirect standard output
  and standard error to a file, or terminal or to command.

  To redirect use file descriptor number, for example to redirect
  stderr use:
  #+BEGIN_EXAMPLE
  some_program 2> errorout
  some_program > outfile
  #+END_EXAMPLE

** Pipe
  Many small programs cooperate together to accomplish some complex
  task. This is done by using =pipes=.
  #+BEGIN_EXAMPLE
  prog1 | prog2 | prog3
  #+END_EXAMPLE

  This is very efficient as prog2 and prog3 does not have to wait for
  the previous pipe programs to complete before they begin hacking at
  the data in their input streams. In addition to this there is no
  need to save output in a temporary file between the stages in
  pipeline. Which saves disk space and improves efficiency as disk I/O
  is often slowest bottleneck in getting something done.

** locate
  locate command uses database of files and directories for
  searching. =updatedb= command updates the database. Linux does
  update once in a day, but the command can be run explicitly as well.

  Following example command will print absolute path of all the files
  and directories matching the give name.
  #+BEGIN_EXAMPLE
  locate test
  #+END_EXAMPLE

** find
  find command recurses down the file system tree from the specified
  directory and searches for file matching given conditions. The
  default directory is present directory.
  #+BEGIN_EXAMPLE
  find /usr -type d -iname directory_name
  find /usr -type f -iname file_name
  find /usr -type l -iname link_name
  #+END_EXAMPLE
   
  find command has very useful options used for administration.  With
  these options number can be expressed either as =n= that means
  exactly that value, =+n= which means greater than that number, or
  =-n= which means lesser than the number.

  1. To find files based on their size, =-size= option is used
     #+BEGIN_EXAMPLE
     find / -size +10M
     find / -size 0
     #+END_EXAMPLE

  2. To find files and execute some command on them, =-exec= option is
     used.
     #+BEGIN_EXAMPLE
     find / -size +10M -exec rm {} \;
     #+END_EXAMPLE
     Where 'rm' is the command to run, '{}' is the placeholder which
     will be replaced with files and ';' is used to indicate end.

  3. To find files based on time:
     + =-ctime= for searching based on created time
     + =-atime= for searching based on accessed/read time
     + =-mtime= for searching based on modified/write time
     
     The number is the number of days.
     #+BEGIN_EXAMPLE
     find \ -ctime 1
     #+END_EXAMPLE
    
     There are similar options for times in minutes (as in =-cmin=,
     =-amin= and =-mmin=)
    
** Working with files
  Following commands can be used to view files.
|---------+--------------------------------------------------------------------------------|
| command | usage                                                                          |
|---------+--------------------------------------------------------------------------------|
| cat     | Used for viewing files that are not very long; it does provide any scroll-back |
|---------+--------------------------------------------------------------------------------|
| tac     | Used to look files backwards;                                                  |
|---------+--------------------------------------------------------------------------------|
| less    | Used to view larger files because it is a paging program; it pauses at each    |
|         | screenful of text, provides scroll-back capabilities, and lets you search and  |
|         | navigate within the file.                                                      |
|---------+--------------------------------------------------------------------------------|
| tail    | Used to print the last 10 lines of a file by default. The number of lines can  |
|         | be changed by doing -n 15 or just -15                                          |
|---------+--------------------------------------------------------------------------------|
| head    | The opposite of tail                                                           |
|---------+--------------------------------------------------------------------------------|
 
** touch
  touch is used to set or update access, change and modify times of
  files. By default it resets a file's time stamp to match the current
  time.

  touch command can also be used to create empty files. This is
  normally done to create empty files as a placefolder for a later
  purpose.

  To set timestamp of a file use =touch= command with =-t= option.
  #+BEGIN_EXAMPLE
  touch -t 03201600 file
  #+END_EXAMPLE

** mkdir
  mkdir command is used to create a directory.
  #+BEGIN_EXAMPLE
  mkdir test
  mkdir test/test2
  #+END_EXAMPLE

** command line prompt
  The PS1 variable is the character string that is displayed as the
  prompt on the command line.
  #+BEGIN_EXAMPLE
  yogesh@machine:~/projects/documents$ echo $PS1
  \[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\u@\h:\w\$
  #+END_EXAMPLE

* Package management
  Package management systems provide two tool levels; a low-level tool
  (such as dpkg or rpm), takes care of the unpacking of individual
  packages, running scripts, getting the software installed correctly,
  while a high level tool (such as apt-get or yum) works with groups
  of packages, downloads packages from the vendor, and figures out
  dependencies.

  Dependency tracking is a particularly important feature of the
  high-level tool as it handles the details of finding and installing
  each dependency. Installing a single packages could result in many
  dozens or even hundreds of dependent packages being installed.

** apt
  The advanced packaging tool (apt) is the package management system
  that manages software on Debian-based systems. It forms the backend
  for graphical package managers, such as the Ubuntu Software Center
  and synaptic. Its native user interface at the command line, with
  programs that include =apt-get= and =apt-cache=.

  Following table presents some basic commands using for debian and
  fedora family system.
|--------------------------------+--------------------+-------------------------|
| Operation                      | RPM                | deb                     |
|--------------------------------+--------------------+-------------------------|
| Install package                | rpm -i foo.rpm     | dpkg --install foo.deb  |
|--------------------------------+--------------------+-------------------------|
| Install package, dependencies  | yum install foo    | apt-get install foo     |
|--------------------------------+--------------------+-------------------------|
| Remove package                 | rpm -e foo.rpm     | dpkg --remove foo.deb   |
|--------------------------------+--------------------+-------------------------|
| Remove package, dependencies   | yum remove foo     | apt-get remove foo      |
|--------------------------------+--------------------+-------------------------|
| Update package                 | rpm -U foo.rpm     | dpkg --install foo.deb  |
|--------------------------------+--------------------+-------------------------|
| Update package, dependencies   | yum update foo     | apt-get install foo     |
|--------------------------------+--------------------+-------------------------|
| Update entire system           | yum update         | apt-get dist-upgrade    |
|--------------------------------+--------------------+-------------------------|
| Show all installed packages    | rpm -qa or         | dpkg --list             |
|                                | yum list installed |                         |
|--------------------------------+--------------------+-------------------------|
| Get information on package     | rpm -qil foo       | dpkg --listfiles foo    |
|--------------------------------+--------------------+-------------------------|
| Show packages named foo        | yum list "foo"     | apt-cache search foo    |
|--------------------------------+--------------------+-------------------------|
| Show all available packages    | yum list           | apt-cache dumpavail foo |
|--------------------------------+--------------------+-------------------------|
| What packages is file part of? | rpm -qf file       | dpkg --search file      |
|--------------------------------+--------------------+-------------------------|
  
* COMMENT Plan
  - Proposed plan to do this course is to spend daily one hour
    attending classes.
  - Revise ch-3 boot process again at the end of the course.

* Useful links
  - http://linuxcommand.org/tlcl.php (resource for commands help)
  - https://www.centos.org/docs/ (centos documentaion)
  - http://refspecs.linuxfoundation.org/fhs.shtml (file system)
  -
    https://courses.edx.org/asset-v1:LinuxFoundationX+LFS101x+1T2016+type@asset+block/LFS101_Ch3_Sec1_FSH.pdf
   (filesystem)
