#+Title: Linux Foundation Course
#+Author: Yogesh Agrawal
#+Date: <2016-03-19 Sat>
#+Email: yogeshiiith@gmail.com

* Introduction
  This document has the learning which I learn from the Linux
  Foundation Course: LFS101x in edx.

* Linux requirements
  The technical differences are mainly about package management
  systems, software versions, and file locations.
** Key facts about Debian Family
   - The Debian family is upstream for Ubuntu.
   - The Linux Kernel 3.13 is used in Ubuntu 14.04
   - It uses the DPKG-based apt-get package manager to install,
     update, and remove packages in the system.

** Key facts about Fedora Family
   - The fedora family is upstream for CentOS, RHEL, and Oracle Linux.
   - The Linux kernel 2.6.32 is used in RHEL/CentOS 6.x
   - It uses the RPM-based yum package manager to install, update and
     remove packages in the system.

* Linux philosophy
  Linux is derived heavily from UNIX operating system. Files are
  organized in a hierarchical filesystem, with the top node of the
  system being root or =/=. Linux components are made available via
  files or objects that look like files. Processes, devices and
  network sockets are all represented by file-like objects, and can
  often be worked with same utilities used for regular files.

  Linux is a multiuser and multitasking operating system, with built
  in networking and service processes known as daemons in the UNIX
  world.

* Linux terminology
** Kernel
   Kernel is the brain of the Operating System. It controls the
   hardware and make hardware available for applications. Latest Linux
   kernel can be seen from http:://kernel.org site.

** Distribution
   Distribution is the bunch of programs combined together with Linux
   kernel to make a Linux based Operating System. Example are Fedora
   and Debian.

** Boot Loader
   Program that boots the operating system. Example are GRUB and
   ISOLinux.

** Service
   Service is a program that runs as a background process. Example
   httpd, nfsd, ftpd and named.

** Filesystem
   Method for storing and organizing files. Example are ntfs, ext3,
   ext4, FAT, NTFS.

** X Windows System
   Provides toolkit or protocol to build graphical interfaces in
   nearly all Linux system.

** Desktop Environment
   Graphical user interface on top of Linux operating system. Example
   are GNOME and KDE.

** Command Line
   Interface for typing commands on top of the operating system.

** Shell
   Command line interpreter that interprets the command line input and
   instructs the operating system to perform any necessary tasks and
   commands. Example are bash and zshell.
 
* Partitions and Filesystems
  Partition is a logical part of the disk, whereas filesystem is a
  method of storing/finding files on a hard disk. You can think of
  filesystems as being like a family tree and partitions as different
  families each of which as its own tree.

* Filesystem hierarchy standard
  Linux filesystem names are case sensitive, that means =/boot=, =/Boot=
  and =/BOOT= represent three different directories. Many distributions
  distinguish between core utilities needed for proper system operation
  and other programs. So other programs are placed inside =/usr=
  directory. Example of directories inside =/= root directory.
  #+BEGIN_EXAMPLE
  .
  |-- bin
  |-- boot
  |-- cdrom
  |-- dev
  |-- etc
  |-- home
  |-- lib
  |-- lib64
  |-- lost+found
  |-- media
  |-- mnt
  |-- opt
  |-- proc
  |-- root
  |-- run
  |-- sbin
  |-- srv
  |-- sys
  |-- tmp
  |-- usr
  `-- var
  #+END_EXAMPLE

* The Boot Process
  - Boot process is the procedure of initializing the system.

  - Understanding boot process will help in troubleshooting systems
    issues more elegantly.

  - The boot process consists of following 9 steps:
    #+BEGIN_EXAMPLE
    1. Power On
    2. BIOS
    3. MBR - Master Boot Record
    4. Boot Loader
    5. Kernel OS
    6. Init Ramfs
    7. /sbin/init
    8. Shell
    9. Graphics
    #+END_EXAMPLE

** BIOS
   Basic Input/Output System initializes the hardware, including the
   screen and keyboard, and tests the main memory. The BIOS software
   is stored on ROM chip on motherboard. After this the remainder of
   the boot process is completely controlled by the operating system.

** Master boot record
   Searches for the boot loader and loads into the RAM.

** Boot Loader
   Boot loader is stored on the boot sector. Boot loaders present a
   user interface for user to choose from available option of
   operating systems. Boot loader is responsible for loading kernel
   image and the initial RAM disk (which contains some critical files
   and device drivers needed to start the system) into memory.

*** Boot loader in action
    The boot loader resides at the first sector of the hard disk also
    known as the Master Boot Record (MBR). The size of the MBR is just
    512 bytes. Boot loader first finds the bootable partition. Once it
    finds the bootable partition it then searches for the second level
    boot loader - GRUB. It then loads the grub into the main memory.
    
    Boot loader displays options which allows us to choose different
    available operating systems. After choosing the operating system
    boot loader loads the kernel into the main memory and passes
    control to it.
    
    Kernel are always compressed when loaded into main memory so its
    first job is to uncompress itself. After this it will check and
    analyze the system hardware and initialize any hardware device
    driver built into the kernel.

** Linux Kernel
   The boot loader loads the kernel and initial ram file system in the
   main memory. Kernel initializes all hardware systems attached to
   the machine this includes all processors, I/O systems, storage
   devices etc. Kernel also loads some necessary user level
   applications into the main memory.

** /sbin/init process
   Once the kernel has setup all the hardware and mounted the root
   file system, the kernel runs the =/sbin/init= program.
  
   init is responsible for keeping the system running and shutting
   down. It is responsible for all non-kernel processes, cleaning up
   after them when necessary, and restarts user login services as
   needed when using log in and out.

** X Windows system
   We can start the default display manager after logging on to a
   text-mode console, and running *startx* from the command line.

* Linux Installation
** Choosing Distribution
   Questions that are to be asked while choosing Linux distributions:
   - What is the main purpose of the OS, server or desktop ?
   - How much disk space is available ?
   - How often packages are updated in a particular distribution ?
   - What is the architecture of the hardware ?

** Partition
   Decide how you want to partition the disk to install OS. You may
   choose to have separate partition for =/home=, =/var= and =/root=.

** Source of installation
   - optical disk: cd, dvds
   - usb
   - network boot

** Automating installation
   Installation process can be automated using a configuration file
   specifying the installation options. For debian-based system file
   is called =preseed=. Example preseed file is here hosted on
   internet by help-ubuntu community:
   https://help.ubuntu.com/lts/installation-guide/example-preseed.txt

** Restart, sleep and shutdown
   - System asks for confirmation while shutting down because many
     applications do not save their data properly when terminated
     while running.

   - Sleep mode works by keeping the applications, desktop and so on
     in RAM and turning off all other hardware.

* Gnome desktop environment
  - Gnome is popular desktop environment and graphical user interface
    that runs on top of the Linux operating system.
  - Ubuntu has =unity= desktop manager which is based on gnome.
  - "Nautilus" is the file browser in gnome.
  - File manager shows following default directories:
    + HOME directory :: User's home directory
    + Computer :: Different drives attached to the system such as hard
                  disk drives, cd/dvd, usb pendrives etc.
    + Network :: Networked and shared devices such as Network shares,
                 printers and file servers.
  - Removing a file, moves the file to trash folder. Trash folder is
    located at =~/.local/share/Trash/files/=.
  - Logging out kills all processes in your current *X* session and
    returns to the display manager.

* System configuration using graphical interface
** Display settings
   Default configuration is to show a large big screen spanning all
   the monitors. We can change this to display same screen in all the
   monitors by =mirroring=.

** Data and time settings
   Linux always uses UTC (Coordinated Universal Time) for its internal
   time settings.

** Network time protocol (NTP)
   NTP is the most popular and reliable protocol for setting local
   time from internet servers. Linux can set the system's local time
   by referring to specific time servers run by distribution.

** Network Configuration
   All Linux distributions have configuration files for managing
   network. File formats and locations can differ from one
   distribution to another. Hand editing these files can handle
   complicated setup. For simple configuration *Network Manager* tool
   was designed. It can lists all available networks (both wired and
   wireless), allow the choice of a wired, wireless or mobile
   broadband network, handle passwords and set vpn. Network manager
   establishes the connections and keep track of your settings.

   The hardware interface and presence of signal is automatically
   detected and then network manager sets the actual network settings
   via *DHCP*. Static configuration can also be done via network
   manager.

   Network manager can manage vpn connections also. It supports many
   VPN technologies such as IPSec.
  
* Linux Documentation Sources
** Man pages
   man stands for manual pages. man program searches, formats and
   displays the information contained in the man pages. Many topics
   have a lot of information, output is piped through a terminal pager
   (less) program such as less to be viewed one page at a time.

   man pages provide in-depth documentation about programs and other
   topics about the system including configuration files, system
   calls, library routines, and the kernel.

   man pages are organized together in the form of 9 chapters. The
   chapter number can be used to force man to display the page from a
   particular chapter.

   - man -f :: searches for man pages containing a string in
               them. generates the result as typing *whatis*
   - man -k :: view all man pages that discuss a specified
               subject. generates the same result as typing *apropos*
   - man -a :: man will display all pages with the given name in all
               chapters, one after the other.

** gnu info
   we can use =info <topic-name>= to information about the topic.

** help
   =topic -h= or =topic --help= are used for quick reference.  =help=
   display a short synopsis of built-in shell commands.

** Desktop help
   we can start the desktop help system from a graphical terminal
   using the =gnome-help= command.

** Package documentation
   This documentation is directly pulled from the upstream source
   code.  It can also contain information about how the distribution
   is packaged and set up the software. Such information is placed
   under the =/usr/share/doc= directory in a subdirectory named after
   the package, perhaps including the version number in the name.

** Online resources
   - https://www.centos.org/docs/ (centos documentation)
   - http://linuxcommand.org/tlcl.php (Linux command help)

* Command line operations
** X Windows system
   The customizable nature of Linux allows you to drop (temporarily or
   permanently) the X windows graphical interface, or to start it up
   after the system has been running.

   Linux production servers are usually installed without X and even
   if it is installed, usually do not launch it during start
   up. Removing X from a production server can be very helpful in
   maintaining a lean system which can be easier to support and keep
   secure.

** Virtual Terminals
   Virtual terminals are console sessions that use entire display and
   keyboard outside of a graphical environment. Such terminals are
   considered "virtual" because it is not same as command line
   terminal window. Although you can have multiple active terminals,
   only one terminal remains visible at a time.

   Example situation where virtual terminal can be used is when we
   face problem with graphical interface, then we can switch to one of
   the virtual terminal and troubleshoot the problem.

   To switch between the VTs, press *ctrl-alt-corresponding function
   key* for the VT. Example: you will have to press *ctrl-alt-F6* for
   VT 6.  You only have to press *alt-F6* if you are in already in a
   VT not running X and want to switch to another VT.

** Command line
   There are three basic elements of a command line:
   - command :: actual command
   - options :: switch to the commands
   - arguments :: input over which command operates on

** Turn off graphical desktop
   In debian based system desktop manager runs as a service. We can
   stop the service at anytime. For rpm-based system the desktop
   manager is run directly by init when set to run level 5; switching
   to a different runlevel stops the desktop.

   1. In debian based system
      #+BEGIN_EXAMPLE
      sudo service lightdm stop
      sudo service gdm stop
      #+END_EXAMPLE

   2. In RPM based system
      #+BEGIN_EXAMPLE
      sudo telinit 3
      #+END_EXAMPLE

** Schedule shutdown
   Schedule system's shutdown and inform all the users logedin to the
   system.
   #+BEGIN_EXAMPLE
   shutdown -h 10:00 "Shutting down for scheduled maintenance"
   #+END_EXAMPLE

** Locating applications
   1. One way is to use which, it searches only for executables.
      #+BEGIN_EXAMPLE
      $ which apt-get 
      /usr/bin/apt-get
      #+END_EXAMPLE
   2. Another way is to use whereis. It looks for the packages in a
      broader range of system directories.
      #+BEGIN_EXAMPLE
      $ whereis apt-get
      apt-get: /usr/bin/apt-get /usr/bin/X11/apt-get /usr/share/man/man8/apt-get.8.gz
      #+END_EXAMPLE

** Stat
   Status of the file can be found using =stat= command. Links values
   shows the number of hard links the file have including itself.
   #+BEGIN_EXAMPLE
   yogesh@machine:~/projects/documents$ stat linux-foundation-course.org 
   File: 'linux-foundation-course.org'
   Size: 14462     	Blocks: 32         IO Block: 4096   regular file
   Device: 807h/2055d	Inode: 4071531     Links: 1
   Access: (0664/-rw-rw-r--)  Uid: ( 1000/  yogesh)   Gid: ( 1000/  yogesh)
   Access: 2016-04-03 10:33:40.382986825 +0530
   Modify: 2016-04-03 10:00:57.074984368 +0530
   Change: 2016-04-03 10:36:33.314987042 +0530
   Birth: -
   #+END_EXAMPLE

** Hard and Soft links
   - Soft link :: Soft link is a new file which only contains the name
                  of the original file. It has different inode number
                  than the original file. Symlinks works across the
                  filesystem. If the original file is deleted the
                  symlink will no longer be valid, however the file
                  will continue to exist.
                  #+BEGIN_EXAMPLE
                  ln -s original-file symlink
                  #+END_EXAMPLE
   - Hard link :: Hard link is a new file which points to the same
                  inode number as the original file. If original file
                  is deleted the hard link will still exist. When
                  either of the hard link or original file is modified
                  the changes are reflected in both of the files. If
                  we delete the original file, the hard link will
                  still exist. The inode will only be deleted when all
                  the links to it are deleted. Hard link does not work
                  across the filesytem. The hard link and the original
                  file has to be in the same filesystem. To create a
                  hard link use following command:
                  #+BEGIN_EXAMPLE
                  ln original-file hardlink
                  #+END_EXAMPLE
** File streams
   When a command is run, three file descriptors are open by default
   one for reading standard input (*stdin*), one for writing standard
   output (*std out*) and one for writing standard error (*std
   err*). These files are accessed via file descriptors.

   In Linux all open files are represented by file descriptors. File
   descriptors are number starting with 0 for stdin, 1 for stdout and
   2 for stderr. If any other descriptors are open in addition to
   these default descriptors, then there numbering will start after 3.

   stdin is usually keyboard, stdout and stederr are terminal by
   default. These descriptors can be changed as per the
   requirements. For example we can make command to take input from a
   file and write to a file instead of keyboard using redirection. We
   can also send output of one command to be as the input for another
   command using pipe.

** I/O redirection
   In shell we can redirect the standard file stream so that we can
   get input from a file, or from keyboard. We can redirect standard
   output and standard error to a file, or terminal or to command.

   To redirect use file descriptor number, for example to redirect
   stderr use:
   #+BEGIN_EXAMPLE
   some_program 2> errorout
   some_program > outfile
   #+END_EXAMPLE

** Pipe
   Many small programs cooperate together to accomplish some complex
   task. This is done by using =pipes=.
   #+BEGIN_EXAMPLE
   prog1 | prog2 | prog3
   #+END_EXAMPLE

   This is very efficient as prog2 and prog3 does not have to wait for
   the previous pipe programs to complete before they begin hacking at
   the data in their input streams. In addition to this there is no
   need to save output in a temporary file between the stages in
   pipeline. Which saves disk space and improves efficiency as disk
   I/O is often slowest bottleneck in getting something done.

** locate
   locate command uses database of files and directories for
   searching. =updatedb= command updates the database. Linux does
   update once in a day, but the command can be run explicitly as
   well.

   Following example command will print absolute path of all the files
   and directories matching the give name.
   #+BEGIN_EXAMPLE
   locate test
   #+END_EXAMPLE

** find
   find command recurses down the file system tree from the specified
   directory and searches for file matching given conditions. The
   default directory is present directory.
   #+BEGIN_EXAMPLE
   find /usr -type d -iname directory_name
   find /usr -type f -iname file_name
   find /usr -type l -iname link_name
   #+END_EXAMPLE
   
   find command has very useful options used for administration.  With
   these options number can be expressed either as =n= that means
   exactly that value, =+n= which means greater than that number, or
   =-n= which means lesser than the number.

   1. To find files based on their size, =-size= option is used
      #+BEGIN_EXAMPLE
      find / -size +10M
      find / -size 0
      #+END_EXAMPLE

   2. To find files and execute some command on them, =-exec= option
      is used.
      #+BEGIN_EXAMPLE
      find / -size +10M -exec rm {} \;
      #+END_EXAMPLE
      Where 'rm' is the command to run, '{}' is the placeholder which
      will be replaced with files and ';' is used to indicate end.

   3. To find files based on time:
      + =-ctime= for searching based on created time
      + =-atime= for searching based on accessed/read time
      + =-mtime= for searching based on modified/write time
     
      The number is the number of days.
      #+BEGIN_EXAMPLE
      find / -ctime 1
      #+END_EXAMPLE
    
      There are similar options for times in minutes (as in =-cmin=,
      =-amin= and =-mmin=)
    
** Working with files
   Following commands can be used to view files.
|---------+--------------------------------------------------------------------------------|
| command | usage                                                                          |
|---------+--------------------------------------------------------------------------------|
| cat     | Used for viewing files that are not very long; it does provide any scroll-back |
|---------+--------------------------------------------------------------------------------|
| tac     | Used to look files backwards;                                                  |
|---------+--------------------------------------------------------------------------------|
| less    | Used to view larger files because it is a paging program; it pauses at each    |
|         | screenful of text, provides scroll-back capabilities, and lets you search and  |
|         | navigate within the file.                                                      |
|---------+--------------------------------------------------------------------------------|
| tail    | Used to print the last 10 lines of a file by default. The number of lines can  |
|         | be changed by doing -n 15 or just -15                                          |
|---------+--------------------------------------------------------------------------------|
| head    | The opposite of tail                                                           |
|---------+--------------------------------------------------------------------------------|
 
** touch
   touch is used to set or update access, change and modify times of
   files. By default it resets a file's time stamp to match the
   current time.

   touch command can also be used to create empty files. This is
   normally done to create empty files as a placefolder for a later
   purpose.

   To set timestamp of a file use =touch= command with =-t= option.
   #+BEGIN_EXAMPLE
   touch -t 03201600 file
   #+END_EXAMPLE

** mkdir
   mkdir command is used to create a directory.
   #+BEGIN_EXAMPLE
   mkdir test
   mkdir test/test2
   #+END_EXAMPLE

** command line prompt
   The PS1 variable is the character string that is displayed as the
   prompt on the command line.
   #+BEGIN_EXAMPLE
   yogesh@machine:~/projects/documents$ echo $PS1
   \[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\u@\h:\w\$
   #+END_EXAMPLE

* Package management
  Package management systems provide two tool levels; a low-level tool
  (such as dpkg or rpm), takes care of the unpacking of individual
  packages, running scripts, getting the software installed correctly,
  while a high level tool (such as apt-get or yum) works with groups
  of packages, downloads packages from the vendor, and figures out
  dependencies.

  Dependency tracking is a particularly important feature of the
  high-level tool as it handles the details of finding and installing
  each dependency. Installing a single packages could result in many
  dozens or even hundreds of dependent packages being installed.

** apt
   The advanced packaging tool (apt) is the package management system
   that manages software on Debian-based systems. It forms the backend
   for graphical package managers, such as the Ubuntu Software Center
   and synaptic. Its native user interface at the command line, with
   programs that include =apt-get= and =apt-cache=.

   Following table presents some basic commands using for debian and
   fedora family system.
|--------------------------------+--------------------+-------------------------|
| Operation                      | RPM                | deb                     |
|--------------------------------+--------------------+-------------------------|
| Install package                | rpm -i foo.rpm     | dpkg --install foo.deb  |
|--------------------------------+--------------------+-------------------------|
| Install package, dependencies  | yum install foo    | apt-get install foo     |
|--------------------------------+--------------------+-------------------------|
| Remove package                 | rpm -e foo.rpm     | dpkg --remove foo.deb   |
|--------------------------------+--------------------+-------------------------|
| Remove package, dependencies   | yum remove foo     | apt-get remove foo      |
|--------------------------------+--------------------+-------------------------|
| Update package                 | rpm -U foo.rpm     | dpkg --install foo.deb  |
|--------------------------------+--------------------+-------------------------|
| Update package, dependencies   | yum update foo     | apt-get install foo     |
|--------------------------------+--------------------+-------------------------|
| Update entire system           | yum update         | apt-get dist-upgrade    |
|--------------------------------+--------------------+-------------------------|
| Show all installed packages    | rpm -qa or         | dpkg --list             |
|                                | yum list installed |                         |
|--------------------------------+--------------------+-------------------------|
| Get information on package     | rpm -qil foo       | dpkg --listfiles foo    |
|--------------------------------+--------------------+-------------------------|
| Show packages named foo        | yum list "foo"     | apt-cache search foo    |
|--------------------------------+--------------------+-------------------------|
| Show all available packages    | yum list           | apt-cache dumpavail foo |
|--------------------------------+--------------------+-------------------------|
| What packages is file part of? | rpm -qf file       | dpkg --search file      |
|--------------------------------+--------------------+-------------------------|
| List packages matching given   |                    | dpkg -l <package-name>  |
| pattern                        |                    |                         |
|--------------------------------+--------------------+-------------------------|

*** remove
    It is used to remove packages. Removing a package leaves its
    configuration files on the system.
*** purge
    It is identical to remove except that the packages are removed and
    purged (any configuration files are deleted too).
*** autoremove
    It is used to remove packages that were automatically installed to
    satisfy dependencies of other packages and are now no longer needed.

* File Systems
** Partitions in linux
   Each filesytem resides on a hard disk partition. Partitions help
   organize the contents of disks according to the kind of data
   contained and how it is used. For example important programs
   required to run the system are often kept on a separate partition
   (known as root or /) than the one that contains files owned by
   regular users of that system (/home). Temporary files created and
   destroyed during normal linux operations are kept on a separate
   partition (/tmp).

** Mount points
   Filesystem are usable only after they are mounted on some
   directory. Filesystem are often mounted on empty directory. If
   mounted on nonempty directory the former contents is covered up and
   not accessible until the filesystem is unmounted. Thus filesystems
   are mounted on empty directory.

   The =mount= command is used to attach a filesystem (which can be
   local to computer or on a network) somewhere within the filesystem
   tree. Arguments include the =device node= and =mount point=. For
   example following command will attach the filesystem contained in
   the disk partition associated with the =/dev/sda5= device node,
   into the filesystem tree at the =/home= mount point.
   #+BEGIN_EXAMPLE
   $ mount /dev/sda5 /home
   #+END_EXAMPLE

   To make the partition, mount automatically at the time of startup,
   we need to edit the =/etc/fstab= file. Looking at this file will
   show us the configuration of all pre-configured filesystems.

   The command =df -Th= will display information about the mounted
   filesystems including usage statistics.
   #+BEGIN_EXAMPLE
   $ df -Th
   Filesystem     Type      Size  Used Avail Use% Mounted on
   udev           devtmpfs  1.9G  4.0K  1.9G   1% /dev
   tmpfs          tmpfs     385M  1.3M  383M   1% /run
   /dev/sda5      ext4       20G  7.5G   12G  41% /
   none           tmpfs     4.0K     0  4.0K   0% /sys/fs/cgroup
   none           tmpfs     5.0M     0  5.0M   0% /run/lock
   none           tmpfs     1.9G  328K  1.9G   1% /run/shm
   none           tmpfs     100M   60K  100M   1% /run/user
   /dev/sda7      ext4      100G   62G   33G  66% /home
   #+END_EXAMPLE
  
* Network Filesystem (NFS)
  Network filesystem is one of the methods used for sharing data
  across physical systems. Remote user's home directory can be mounted
  on a server to allow access to the same files and configuration
  files across multiple client systems. This allow users to log in to
  different computers yet still have access to the same files and
  resources.
** NFS on the server
   On the server machine, directories and permissions are defined to
   allow sharing of files over nfs. File =/etc/exports= contains the
   directories and permissions that a host is willing to share with
   other systems over NFS. Below example allows =/projects= directory
   to be remotely mounted with read and write permissions.
   #+BEGIN_EXAMPLE
   /projects *.example.com(rw)
   #+END_EXAMPLE
  
   After modifying the =/etc/exports= file we can notify Linux about
   the change by executing =exportfs -av= command. Restarting NFS with
   =sudo service nfs restart= will also work, but is heavier as it
   halts NFS for a short while before starting it up again.

** NFS on the client
   On the client machine we can mount the remote filesystem by
   following command.
   #+BEGIN_EXAMPLE
   mount servername:/projects /mnt/nfs/projects
   #+END_EXAMPLE
   To automatically mount the remote filesystem make an entry in
   =/etc/fstab= as follows:
   #+BEGIN_EXAMPLE
   servername:/projects /mnt/nfs/projects nfs default 0 0
   #+END_EXAMPLE  
* Proc Filesystem
  The =/proc= filesystem contains virtual files, that exist only in
  memory that permit viewing constantly varying kernel data. This
  filesystem contains files and directories that mimic kernel
  structure and configuration information.

  =/proc= has subdirectories such as:
  1. =/proc/<process-id-#>= : There is a directory for every process
     running on the system which contains vital information about it.

  2. =/proc/sys= : This directory contains a lot of information about
     the entire system.
  
* Filesystem architecture
** /bin and /sbin directories
   The =/bin= directories contains executable binaries, essential
   commands used in single-user mode, and essential commands required
   by all system users.
  
   =/usr/bin= directory contains commands that are not essential for
   the system. =/sbin= directory contains commands that are essential
   for system administration. =/usr/sbin= contains commands that are
   less essential for system administration.

   The reason essential commands were separately placed in =/sbin= is
   because sometimes =/usr= directory may be mounted on a separate
   partition and may not be available/mounted in a single-user mode.

** /dev directory
   =/dev= directory contains files that are used by most hardware and
   software devices, except for network devices. It creates and
   manages device nodes on Linux, creating them dynamically when
   devices are found.
   1. /dev/sda1 (first partition on the first hard disk)
   2. /dev/lp1 (printer)
   3. /dev/dvd1 (DVD drive)

** /var directory
   =var= stands for variable. =/var= directory contains files that are
   expected to change in size and content as the system is running.
   Example files are:
   1. System log files: /var/log
   2. Database and packages: /var/lib
   3. Print queue: /var/spool
   4. Temp files: /var/tmp

   The =/var= directory can be put in its own filesystem so that the
   growth of the files can be accommodated and the file sizes do not
   affect the system.

   Network service directories such as =/var/ftp= (the ftp service)
   and =/var/www= (the http service) are also found under =/var=.

** /etc directory
   =/etc= directory contains system configuration files. For example,
   =/etc/resolv.conf= tells the system where to go for resolving host
   name to ip address. Files like =passwd=, =shadow= and =group= are
   found in the =/etc= directory.

   System run level scripts are found inside subdirectories of
   =/etc=. For example =/etc/rc2.d= contains links to scripts for
   entering and leaving run level 2.

** /boot directory
   =/boot= directory contains files needed to boot the system. For
   every alternative kernel installed on the system there are
   following four corresponding files:
   1. vmlinuz: the compressed Linux kernel, required for booting
   2. initramfs: the initial ram filesystem, required for booting
   3. config: the configuration file, only used for debugging and bookkeeping
   4. system.map: kernel symbol table used for debugging

   The Grand Unified Bootloader (GRUB) files (such as
   =/boot/grub/grub.conf=) are also found under the =/boot= directory.

** /lib and /media directory
   =/lib= directory contains libraries for the essential programs in
   =/bin= and =/sbin=. These library filenames either start with =ld=
   or with =lib=.

   =/media= is typically located where removable media such as CDs,
   DVDs and USB drives are mounted. Linux automatically mounts the
   removable media in the =/media= directory when they are detected.

** Additional directories under /
|----------------+------------------------------------------------------|
| Directory Name | Usage                                                |
|----------------+------------------------------------------------------|
| /opt           | Optional application software packages               |
|----------------+------------------------------------------------------|
| /tmp           | Temporary files; on some distributions erased across |
|                | a reboot and/or may actually be a ramdisk in memory  |
|----------------+------------------------------------------------------|
| /usr/lib       | Libraries for programs in /usr/bin and /usr/sbin     |
|----------------+------------------------------------------------------|
| /usr/src       | Source code usually for the Linux kernel             |
|----------------+------------------------------------------------------|
 
* Comparing files and filetypes
  =diff= command is used to compare files and directories. To compare
  two files use following command.
  #+BEGIN_EXAMPLE
  diff <filename1> <filename2> 
  #+END_EXAMPLE

|-------------+--------------------------------------------|
| diff option | Usage                                      |
|-------------+--------------------------------------------|
| -r          | Used to recursively compare subdirectories |
|             | as well as the current directory           |
|-------------+--------------------------------------------|
| -i          | Ignore the case of letters                 |
|-------------+--------------------------------------------|
| -w          | Ignore differences in spaces and tabs      |
|-------------+--------------------------------------------|

* Backup
  =rsync= utility in Linux provides useful way to take backup of files
  and folders. =rsync= command can be used to copy files to/from local
  machine as well as to/from network machine.

  =rsync= is efficient in a way that it transfers only the differences
  between the files. Whereas =cp= command transfers the complete
  file.

  =rsync= utility can be destructive if not handled with care. It is
  advisable to always do a dry run using =-dry-run= or =-n= option,
  before doing the actual transfer. Dry run is used in conjunction
  with =--verbose= option.
  #+BEGIN_EXAMPLE
  rsync -r -v -n ~/projects ~/Desktop
  #+END_EXAMPLE

* Archive and compression
  Compression is used to save disk space and reduce the time it takes
  to transfer the files over network. In addition tar utility is often
  used to group files in an archive and then compress the whole
  archive at once.

  =tar= stands for tape archive and is used to archive files to a
  magnetic tape.
  1. Creating a tar of all the files and folders in present working
     directory.
     #+BEGIN_EXAMPLE
     tar -cvf my.tar *
     #+END_EXAMPLE

  Files can be saved in the compressed form, for future use. =xz= is
  the most efficient compression (produces smallest files)
  1. Compress all the files in present working directory.
     #+BEGIN_EXAMPLE
     xz *
     #+END_EXAMPLE
  2. Compress the file foo
     #+BEGIN_EXAMPLE
     xz foo
     #+END_EXAMPLE

  Archiving and compression can be done together using =tar=
  1. Create the archive and compress with =xz=
     #+BEGIN_EXAMPLE
     tar -Jcvf mydir.tar.xz mydir
     #+END_EXAMPLE
  2. Create the archive and compress with =gzip=
     #+BEGIN_EXAMPLE
     tar -zcvf mydir.tar.gz mydir
     #+END_EXAMPLE

* Disk to disk copying
  =dd= command is very useful for making copies of raw disk space. To
  make a copy of one disk onto another, deleting everything that
  perviously existed on the second disk, type:
  #+BEGIN_EXAMPLE
  dd if=/dev/sda of=/dev/sdb
  #+END_EXAMPLE
* Basics of users and groups
  Linux uses groups for organizing users. Groups are collection of
  user accounts with certain shared permissions. Control of group
  membership is administered through the =/etc/group= file, which
  shows a list of groups and their members.

  All Linux users are assigned a unique user ID (uid), which is just
  an integer, as well as one or more group ID's (gid), including the
  default one which is the same as the user ID.

  These numbers are associated with the names through the files
  =/etc/passwd= and =/etc/group=.

** Adding and removing users
   Users can be added and deleted only by the root user. Normal user
   can not perform this action. =adduser= command is used to create
   user and =userdel= command is used to delete user.

   To create an user =turkey= execute following command, which will
   sets the home directory to =/home/turkey=, populates with some
   basic files (copied from =/etc/skel=) and adds a line to
   =/etc/passwd= file.
   #+BEGIN_EXAMPLE
   sudo adduser turkey
   #+END_EXAMPLE

   Removing a user is as simple as typing =userdel turkey=. However
   this will leave the =/home/turkey= directory intact. This might be
   useful if this is a temporary inactivation. To remove the home
   directory while removing the account we can use =-r= option with
   =userdel= command.

   To get the current user information use =id= command.
   #+BEGIN_EXAMPLE
   id
   uid=1000(yogesh) gid=1000(yogesh) groups=1000(yogesh),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),108(lpadmin),124(sambashare),999(docker)
   #+END_EXAMPLE
  
** Adding and removing groups
   1. Adding a new group can be done with =addgroup= command
      #+BEGIN_EXAMPLE
      sudo addgroup <groupname>
      #+END_EXAMPLE
   2. The group can be removed with
      #+BEGIN_EXAMPLE
      delgroup <groupname>
      #+END_EXAMPLE
   3. Adding a user to an already existing group is done with
      =usermod= command.
      #+BEGIN_EXAMPLE
      $ groups turkey
      turkey: turkey
      $ usermod -G <newgroup> turkey
      $ groups turkey
      turkey: turkey newgroup
      #+END_EXAMPLE
  
** root account
   The root account is very powerful and has full access to the
   system. Extreme caution must be taken before granting root access
   to a user. *sudo* feature is used to assign more limited privileges
   to user accounts:
   + on only a temporary basis
   + only for a specific subset of commands

** su and sudo
   We can use =su= command to switch to a new user, and launch a new
   shell running as another user. It is almost always a bad (dangerous
   for both security and stability) practise to use =su= to become
   root.

   Granting privileges using =sudo= is less dangerous and is
   preferred. By default, =sudo= must be enabled on a per-user basis.

   =sudo= configuration files are stored in =/etc/sudoers= file and in
   =/etc/sudoers.d= directory.
 
* Startup files
  In Linux, the command shell program (generally *bash*) uses one or
  more startup files to configure the environment. Files in =/etc=
  directory define global settings for all users while initialization
  files in the user's home directory can include and/or override the
  global settings.

  Startup files can do the following:
  1. Customizing the user's prompt
  2. Defining command line aliases and shortcuts
  3. Setting the default text editor
  4. Setting the *path* for where to find executable programs

** Order of the startup files
   On the first login to Linux, =/etc/profile= is read and
   evaluated. After this following files are searched in the listed
   order:
   1. =~/.bash_profile=
   2. =~/.bash_login=
   3. =~/.profile=

   The Linux login shell evaluates whatever startup file that it comes
   across first and ignores the rest.

   When you create a new shell, or terminal window, etc, you do not
   perform a full system login; only the =~/.bashrc= file is read and
   evaluated.

* Environment Variables
  Environment variables are simply named quantities that have specific
  values and are understood by the command shell, such as *bash*. Some
  of these are pre-set (built-in) by the system, and others are set by
  the user either at the command line or within startup and other
  scripts. An environment variable is actually no more than a
  character string that contains information used by one or more
  applications.

  To view values of currently set environment variables we can type
  any of the following command.
  1. set 
  2. env 
  3. export

  Depending on the state of your system, *set* may print out many more
  lines than the other two methods.

** Setting environment variables
   By default, variables created within a script are only available to
   the current shell; child processes (sub-shells) will not have
   access to values that have been set or modified. Allowing child
   processes to see the values requires use of the *export* command.

** PATH Variable
   PATH is an ordered list of directories (the path) which is scanned
   when a command is given to find the appropriate program or script
   to run. Each directory in the path is separated by colons(:). A
   null (empty) directory name (or ./) indicates the current working
   directory at any given time.

   #+BEGIN_EXAMPLE
   :path1:path2 - there is null directory before the first colon
   path1::path2 - there is null directory between path1 and path2
   #+END_EXAMPLE

** PS1 Variable
   *PS1* is the primary prompt variable which controls what your
   command line prompt looks like.

   A better practise would be to save the old prompt first and then
   restore it as in
   #+BEGIN_EXAMPLE
   $ OLD_PS1=$PS1
   #+END_EXAMPLE

** SHELL Variable
   The environment variable shell points to the user's default command
   shell (the program that is handling whatever you type in a command
   window, usually bash) and contains the full pathname to the shell.
* Recalling previous commands
  *bash* keeps track of previously entered commands and statements in
   a history buffer; you can recall previously used commands simply by
   using the up and down cursor keys.

   The list of commands is displayed with the most recent command
   appearing last in the list. The information is stored in
   =~/.bash_history=

** History environment variable
   Several associated environment variable can be used to get
   information about the history file.

   1. HISTFILE stores the information about the history file.
   2. HISTFILESIZE stores the maximum number of lines in the history
      file.
   3. HISTSIZE stores the maximum number of lines in the history file
      for the current session.

* Keyboard shortcuts
|-------------------+---------------------------------------------------|
| Keyboard shortcut | Task                                              |
|-------------------+---------------------------------------------------|
| CTRL-L            | Clears the screen                                 |
|-------------------+---------------------------------------------------|
| CTRL-H            | Works same as backspace                           |
|-------------------+---------------------------------------------------|
| CTRL-U            | Deletes the string from the beginning of the line |
|                   | to the cursor position                            |
|-------------------+---------------------------------------------------|
| CTRL-W            | Deletes the word before the cursor                |
|-------------------+---------------------------------------------------|
| CTRL-Z            | Puts the current process to background in         |
|                   | suspended state                                   |
|-------------------+---------------------------------------------------|
| CTRL-D            | Exits the current shell                           |
|-------------------+---------------------------------------------------|
| CTRL-C            | Kills the current process                         |
|-------------------+---------------------------------------------------|
| CTRL-A            | Goes to the beginning of the line                 |
|-------------------+---------------------------------------------------|
| CTRL-E            | Goes to the end of the line                       |
|-------------------+---------------------------------------------------|
| TAB               | Auto completes files, directories and binaries    |
|-------------------+---------------------------------------------------|

* Aliases
  We can create customized commands or modify the behaviour of
  already existing commands by creating aliases. These aliases are
  placed in =~/.bashrc= file so they are available to any command
  shells you create.

  Typing =alias= with no arguments will list currently defined
  aliases. Alias can be defined temporarily using =alias=
  command. Example
  #+BEGIN_EXAMPLE
  $ alias ls='ls -l'
  #+END_EXAMPLE

  - Note :: There should not be any spaces on either side of the equal
            sign and the alias definition needs to be placed within
            either single quotes or double quotes if it contains any
            spaces.

* File Ownership
  In Linux every file is associated with a user who is the
  *owner*. Every file is also associated with a group (a subset of all
  users) which has an interest in the file and certain rights, or
  permissions: read, write and execute.

|----------+-------------------------------------|
| *Command | Usage*                              |
|----------+-------------------------------------|
| chown    | Used to change the file ownership   |
|----------+-------------------------------------|
| chgrp    | Used to change the group ownership  |
|----------+-------------------------------------|
| chmod    | Used to modify the file permissions |
|----------+-------------------------------------|

  #+BEGIN_EXAMPLE
  chmod uo+x,g-w test1
  chmod 755 test1
  #+END_EXAMPLE
  
  1. read is 4
  2. write is 2
  3. execute is 1

* Text Editors
  Files can be created without using text editors. There are two
  standard way to create files
  1. echo
     #+BEGIN_EXAMPLE
     echo "File content" > test
     echo "More file content" >> test
     #+END_EXAMPLE
  2. cat
     #+BEGIN_EXAMPLE
     cat << EOF > test
     This text is written inside file
     EOF
     #+END_EXAMPLE

** vi
*** Modes in vi
|---------+---------------------------------------------------------|
| *Mode   | Feature*                                                |
|---------+---------------------------------------------------------|
| Command | - By default vi starts in command mode.                 |
|         | - Each key is an editor command.                        |
|         | - Keyboard strokes are interpreted as commands that can |
|         | modify file contents.                                   |
|---------+---------------------------------------------------------|
| Insert  | - Type 'i' to switch to insert mode from command mode   |
|         | - Insert mode is used to insert text into a file        |
|         | - Insert mode is indicated by the text "-- INSERT --"   |
|         | at the bottom of the screen                             |
|         | - Press Esc to exit insert mode and return to command   |
|         |   mode                                                  |
|---------+---------------------------------------------------------|
| Line    | - Type ":" to switch to line mode from command mode.    |
|---------+---------------------------------------------------------|

*** Working with files in vi
|------------+------------------------------------------------|
| *Command   | Usage*                                         |
|------------+------------------------------------------------|
| vi file    | start vi editor and edit file                  |
|------------+------------------------------------------------|
| vi -r file | start vi editor and edit file in recovery mode |
|            | from system crash                              |
|------------+------------------------------------------------|
| :w         | save content to file                           |
|------------+------------------------------------------------|
| :w file    | write the content to file                      |
|------------+------------------------------------------------|
| :r file    | Read in file and insert at current position    |
|------------+------------------------------------------------|
| :x or :wq  | save the content to file and exit              |
|------------+------------------------------------------------|
| :q         | quit                                           |
|------------+------------------------------------------------|
| :q!        | quit even if there are unsaved modifications   |
|            | to the file                                    |
|------------+------------------------------------------------|
| vi file -R | open file in read mode                         |
|------------+------------------------------------------------|
| :e file    | start editing file                             |
|------------+------------------------------------------------|

*** vi commands
|-----------------------+----------------------------------------------------|
| *Command              | Usage*                                             |
|-----------------------+----------------------------------------------------|
| CTRL-G                | Show location in the file and the file status      |
|-----------------------+----------------------------------------------------|
| G                     | move to the bottom of the file                     |
|-----------------------+----------------------------------------------------|
| gg                    | move to the start of the file                      |
|-----------------------+----------------------------------------------------|
| CTRL-o                | go back to where you came from                     |
|-----------------------+----------------------------------------------------|
| Search command - /    | search for the phrase                              |
|-----------------------+----------------------------------------------------|
| Match parentheses - % | find matching ), ], or }                           |
|-----------------------+----------------------------------------------------|
| R                     | To start replace mode                              |
|-----------------------+----------------------------------------------------|
| CTRL-D                | Show list of commands start with entered character |
|-----------------------+----------------------------------------------------|
| CTRL-W                | Jump to another windows                            |
|-----------------------+----------------------------------------------------|
| x                     | delete character at current position               |
|-----------------------+----------------------------------------------------|

*** vi operators
    1. To delete the text use =d=
    2. To replace the text use =r=
    3. To change the text use =c=
    4. To copy the text use =y=

*** Substitute command
    1. To substitute new for the first old in a line type:
       =:s/old/new=.
    2. To substitute new for all occurrences of old in the line type
       =:s/old/new/g=.
    3. To substitute new for all occurrences of old in the whole file
       type: =:%s/old/new/g=.
    4. To substitute new for all occurrences of old in the whole file
       with confirmation type: =:%s/old/new/gc=.
      
*** External command
    Type =:!= followed by an external command to execute that command.
    #+BEGIN_EXAMPLE
    :!ls
    :!rm test
    :! wc %
    :%!fmt
    #+END_EXAMPLE
    Here =%= represents the file currently being edited.

*** Selecting text to write
    To highlight the text type =v= and then move the cursor to select
    the text. Once the text is highlighted we can save the text into a
    file by typing =:= and then =w test=.

*** set option
    1. set 'ic' (Ignore case) option by entering =:set ic=.
    2. set 'is' ('incsearch') option to show partial matches for a
       search phrase.
    2. set the 'hlsearch' option to highlight all matching phrase.
    3. To disable ignoring case enter: =:set noic=.
    4. To remove the highlighting of matches enter: =:nohlsearch=.

** Emacs
   Following table represents common key combination used while
   editing files in emacs.
   |---------------+-----------------------------------|
   | *key          | Usage*                            |
   |---------------+-----------------------------------|
   | emacs myfile  | Start emacs and edit file         |
   |---------------+-----------------------------------|
   | CTRL-x i      | insert prompted for file          |
   |               | at current position               |
   |---------------+-----------------------------------|
   | CTRL-x s      | save all files                    |
   |---------------+-----------------------------------|
   | CTRL-x CTRL-w | write to the file giving new      |
   |               | name when prompted                |
   |---------------+-----------------------------------|
   | CTRL-x CTRL-s | saves the current file            |
   |---------------+-----------------------------------|
   | CTRL-x CTRL-c | exit after being prompted to save |
   |               | any modified files                |
   |---------------+-----------------------------------|

*** Searching for text in emacs
    The table lists the key combinations that are used for searching
    for text in emacs.
    |--------+---------------------------------------|
    | *Key   | Usage*                                |
    |--------+---------------------------------------|
    | CTRL-s | Search forward for prompted pattern   |
    |--------+---------------------------------------|
    | CTRL-r | Search backwards for prompted pattern |
    |--------+---------------------------------------|

*** Working with text in emacs
    The table lists the key combination used for changing, adding and
    deleting text in emacs.
    |--------------+---------------------------------------------|
    | *Key         | Usage*                                      |
    |--------------+---------------------------------------------|
    | CTRL-k       | delete rest of the current line             |
    |--------------+---------------------------------------------|
    | CTRL-(space) | mark the beginning of the selected region   |
    |--------------+---------------------------------------------|
    | CTRL-w       | delete the current marked text and write it |
    |              | to the buffer                               |
    |--------------+---------------------------------------------|
    | CTRL-y       | insert at current cursor location whatever  |
    |              | was most recently deleted                   |
    |--------------+---------------------------------------------|

* Security Principles
** User accounts
   Linux kernel allows authenticated users to access files and
   applications. While each user is identified by a unique integer
   (the user id or UID), a separate database associates a username
   with each UID. Upon account creation, new user information is added
   to the user database and the user's home directory must be created
   and populated with some essential files.

   For each user following seven fields are maintained in the
   =/etc/passwd= file.

|----------------+---------------------------------------------+------------------------------------------------|
| *Field Name    | Details                                     | Remarks*                                       |
|----------------+---------------------------------------------+------------------------------------------------|
| Username       | User login name                             | Should be in beetween 1 and 32 characters long |
|----------------+---------------------------------------------+------------------------------------------------|
| Password       | User password (or the character x           | Is never shown while typing                    |
|                | if the password is stored in /etc/shadow    |                                                |
|                | file) in encrypted format.                  |                                                |
|----------------+---------------------------------------------+------------------------------------------------|
| User ID (UID)  | Every user must have a user id (UID)        | - UID 0 is reserved for root user              |
|                |                                             | - UID's ranging from 1-99 are reserved for     |
|                |                                             | other predefined accounts                      |
|                |                                             | - UID's ranging from 100-999 are reserved for  |
|                |                                             | systems accounts and groups                    |
|                |                                             | - Normal user have UID's of 1000 or greater    |
|----------------+---------------------------------------------+------------------------------------------------|
| Group ID (GID) | The primary Group ID (GID); Group           |                                                |
|                | identification number stored in the         |                                                |
|                | /etc/group file                             |                                                |
|----------------+---------------------------------------------+------------------------------------------------|
| User Info      | This field is optional and allows insertion |                                                |
|                | of extra information about the user such as |                                                |
|                | their name                                  |                                                |
|----------------+---------------------------------------------+------------------------------------------------|
| Home Directory | The absolute path location of user's home   |                                                |
|                | directory                                   |                                                |
|----------------+---------------------------------------------+------------------------------------------------|
| Shell          | The absolute location of a user's default   |                                                |
|                | shell                                       |                                                |
|----------------+---------------------------------------------+------------------------------------------------|

   Example entry of /etc/passwd file:

   #+BEGIN_EXAMPLE
   daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
   #+END_EXAMPLE

** Types of accounts
   Linux has four types of accounts:
   1. root
   2. System
   3. Normal
   4. Network
    
   For a safe working environment, it is advised to grant the minimum
   privileges possible and necessary to accounts, and remove inactive
   accounts. The *last* command, which shows the last time each user
   logged into the system, can be used to help identify potentially
   inactive accounts which are candidates for system removal. 

   Last searches back through the file /var/log/wtmp and displays list
   of all users logged in (and out) since that file was created. A
   pseudo user logs in each time the system is rebooted.  The last
   reboot command will show a log of all reboots since the log file
   was created.

   *lastb* is the same as *last*, except that by default it shows a
   log of the file =/var/log/btmp=, which contains all the bad login
   attempts.

   The practices you use on multi-user business systems are more
   strict than practices you can use on personal desktop systems that
   only affect the casual user. This is especially true with security.

** root account
   =root= is the most privileged account in Linux system.  This
   account has the ability to carry out all facets of system
   administration, including root accounts, changing passwords,
   examining log files, installing software, etc.  It has no security
   restrictions imposed upon it.

** Operations that require root privileges
   =root= privileges are required to perform operations such as:
   1. creating, removing and managing user accounts.
   2. managing software packages.
   3. removing or modifying system files.
   4. restarting system services.

   =root= privilege is required for performing administration tasks
   such as restarting services and managing parts of the filesystem
   that are outside the normal user's directories.

** Operations that do not require root privileges - SUID
   A regular account user can perform some operations requiring
   special permissions.

   SUID (Set owner User ID upon execution) - is a special kind of file
   permission given to a file. SUID provides temporary permissions to
   a user to run a program with the permissions of file *owner* (which
   may be root) instead of permissions held by the user.

   Examples of files, with suid set:

   1. chmod the user permissions:
      #+BEGIN_EXAMPLE
      -rwsr-xr-x 1 root root 47032 Jan 27 06:20 /usr/bin/passwd
      #+END_EXAMPLE

   2. chmod the group permissions: it runs as someone in the group.
      #+BEGIN_EXAMPLE
      -rwxr-sr-x 1 root shadow 55000 Jan 27 06:20 /usr/bin/chage
      #+END_EXAMPLE
 
   - refer: http://www.linuxnix.com/suid-set-suid-linuxunix/

   - Example1: passwd command ::
        When we try to change password of a user, using passwd command
        which is owned by the root. This =passwd= command will try to
        edit some system config files such as =/etc/passwd= and
        =/etc/shadow= etc when we try to change our password. Some of
        these files can not be viewed/edited by the normal user, only
        root user will have permissions. So if we try to remove SUID
        and give full permissions to this passwd command file it
        cannot open other files such as /etc/shadow file to update the
        changes and we will get permission denied error or some other
        error when tried to execute password command. So passwd
        command is set with SUID to give root user permissions to
        normal user so that it can update /etc/shadow and other files.

   - Example2: ping command ::
	When we execute ping command, it creates sockets internally
        and open ports to send and receive IP packets. Normal user
        don't have permissions to create sockets and open ports, root
        privileges is required to perform this tasks. Hence SUID bit
        is set in ping command/file so that whoever executes this
        command will get owner (root) permissions to open socket files
        and ports.

*** How to set SUID for a file
    1. Symbolic way
       #+BEGIN_EXAMPLE
       u+s file.txt
       #+END_EXAMPLE

    2. Numerical way
       #+BEGIN_EXAMPLE
       chmod 4750 file.txt
       #+END_EXAMPLE

*** Find all the SUID set files
    #+BEGIN_EXAMPLE
    find / -perm +4000
    #+END_EXAMPLE

** sudo vs su
   In Linux you can use either =su= or =sudo= to temporarily grant
   root access to a normal user.

   |--------------------------------------------+---------------------------------------------|
   | *su                                        | sudo*                                       |
   |--------------------------------------------+---------------------------------------------|
   | While elevating privileges root's password | While elevating privileges user's password  |
   | is required. Giving the root password      | is required not the root password           |
   | to a normal user should never ever be done |                                             |
   |--------------------------------------------+---------------------------------------------|
   | Once entered using su, a user can perform  | sudo provides various configurable features |
   | all the tasks of root user, for as long as | to control and limit access. User has to    |
   | the user wants without being asked again   | every time provide password while executing |
   | for the password.                          | command or the password will be saved for   |
   |                                            | the configurable interval.                  |
   |--------------------------------------------+---------------------------------------------|
   | It has limited logging features.           | Actions details are logged in a log file.   |
   |                                            | sudo commands and failures are logged in    |
   |                                            | /var/log/auth.log under the Debian system   |
   |                                            | and /var/log/messages in other distribution |
   |                                            | system.                                     |
   |--------------------------------------------+---------------------------------------------|
  
** Sudoers file
   Whenever sudo is invoked, a trigger will look at =/etc/sudoers= and
   the files in =/etc/sudoers.d= to determine if the user has the
   right to use sudo and what the scope of their privilege is.

   It is preferred to add a file in the directory =/etc/sudoers.d=
   with a name the same as the user. This file contains the individual
   user's sudo configuration, and one should leave the master
   configuration untouched except for changes that affect all users.

   The basic structure of an entry is:
   #+BEGIN_EXAMPLE
   who where = (as_whom) what
   #+END_EXAMPLE

   sudoers file must be edited carefully. We can edit the sudoers file
   using =visudo= command. If there are any mistakes in the file, then
   you will not be able to execute the sudo command. The best way to
   edit sudoers file is to use =visudo= command, for example:
   #+BEGIN_EXAMPLE
   sudo visudo -f /etc/sudoers.d/user1
   #+END_EXAMPLE
   This ensures that only one person is editing the file at a time,
   has the proper permissions, refuses to write out the file and exit
   if there is an error in the changes made.

   If there are any syntax errors in the sudoers file then you will
   not be able to execute root privileged command. Then you have to
   use =pkexec= command as follows to correct the error.

   #+BEGIN_EXAMPLE
   pkexec visudo -f /etc/sudoers.d/filename
   #+END_EXAMPLE

   =pkexec= is a similar command to =sudo=. It allows user to execute
   a command as another user.

   Refer the below link to understand better:
   http://askubuntu.com/questions/73864/how-to-modify-a-invalid-etc-sudoers-file-it-throws-out-an-error-and-not-allowi

** command logging
   *sudo* commands are logged in =/var/log/auth.log= under the Debian
   distribution, and in =/var/log/secure= or =/var/log/messages= on
   other systems.

   A typical entry of the message contains:
   - calling username
   - terminal info
   - working directory
   - user account invoked
   - command with arguments

   Running a command such as sudo results in a log file entry such as:
   #+BEGIN_EXAMPLE
   1 May 23 08:06:17 machine sudo:   yogesh : TTY=pts/11 ; PWD=/home/yogesh/work/projects/documents/linux ; USER=root ; COMMAND=/usr/bin/whoami
   #+END_EXAMPLE 

** Process Isolation
   Linux is considered to be more secure than many other operating
   systems, because processes are naturally isolated from each
   other. One process normally can not access the resources of another
   process, even when that process is running with the same user
   privileges. Linux thus makes it difficult for viruses and security
   exploits to access and attack random resources on a system.

** Security mechanism
   Additional security features that have been recently introduced in
   order to make risks even smaller are:

*** Control Groups (cgroups):
    Allow system administrators to group processes and associate
    finite resources to each cgroup.

*** Linux Containers (LXC):
    Makes it possible to run multiple Linux systems (containers) on a
    single system by relying on *cgroups*.

*** Virtualization
    Hardware is emulated in such a way that not only processes can be
    isolated, but entire systems are run simultaneously as isolated
    and insulated guests (virtual machine) on one physical host.
   
** Hardware Device Access
   Linux limits user access to non-networking hardware devices in a
   manner that is extremely similar to regular file
   access. Applications interact by engaging the filesystem
   layer. This layer will then opens a *device special file* under the
   */dev* directory that corresponds to the device being
   accessed. Each device special file has standard owner, group and
   world permission fields. Security is naturally enforced just as it
   is when standard files are accessed.

   Hard disks, for example, are represented as /dev/sd*. While a root
   user can read and write to disk in a raw fashion
   #+BEGIN_EXAMPLE
   $ echo hello world > /dev/sda1
   #+END_EXAMPLE

   #+BEGIN_EXAMPLE
   $ ls -l /dev/sda
   brw-rw---- 1 root disk 8, 0 May 24 07:09 /dev/sda
   #+END_EXAMPLE

   the standard permissions as shown above make it impossible for
   regular users to do so. Writing to a device in this fashion can
   easily obliterate the filesystem stored on it in a way that cannot
   be repaired without great effort, if at all.

** Update System
   When security problems in either the Linux kernel or applications
   and libraries are discovered, Linux distributions have a good
   record of reacting quickly and pushing out fixes to all systems by
   updating their software repositories and sending notifications to
   update immediately. The same thing is true with bug fixes and
   performance improvements that are not security related.

   Many of the most successful attack vectors come from exploiting
   security holes for which fixes are already known but not
   universally deployed.

   So the best practise is to take advantage of your Linux
   distribution's mechanism for automatic updates and never postpone
   them. It is extremely rare that such an update will cause new
   problems.

** Passwords
   The system verifies authenticity and identifies, using user
   credentials. Originally, encrypted passwords were stored in the
   =/etc/passwd= file, which was readable by everyone. This made it
   rather easier for passwords, to be cracked. On modern systems,
   passwords are actually stored in an encrypted format in a secondary
   file named =/etc/shadow=. Only those with root access can
   modify/read this file.

** Password Encryption
   Linux distributions rely on a modern password encryption algorithm
   called *SHA-512* (Secure Hashing Algorithm 512 bits). The SHA-12
   algorithm is widely used for security applications and
   protocols. These security applications and protocols include TLS,
   SSL, PHP, SSH, S/MIME and IPSec. *SHA-512* is one of the most
   tested hashing algorithms.
  
   Example:
   #+BEGIN_EXAMPLE
   $ echo -n test | sha512sum 
   0e3e75234abc68f4378a86b3f4b32a198ba301845b0cd6e50106e874345700cc6663a86c1ea125dc5e92be17c98f9a0f85ca9d5f595db2012f7cc3571945c123  -
   #+END_EXAMPLE

** Good Password Practices
*** Password aging
    It is a method to ensure that users get prompts that remind them
    to create a new password after a specific period. This can ensure
    that passwords, if cracked, will only be usable for a limited
    amount of time. This feature is implemented using *chage*, which
    configures the password expiry information for a user.
  
    Executing *chage* command requires root privileges because the
    command edits the user information in =/etc/shadow= file which is
    owned by the root. =/etc/shadow= file has following permissions:
    #+BEGIN_EXAMPLE
    -rw-r----- 1 root shadow 1154 May 25 20:00 /etc/shadow
    #+END_EXAMPLE

    Examples:
    1. set maximum number of days during which password is valid. When
       MAX_DAYS plus LAST_DAYS is less than the current day, the user
       will be required to change the password before being able to
       use the account.
       #+BEGIN_EXAMPLE
       sudo chage yogesh -M 2
       #+END_EXAMPLE

       Passing the number =-1= as the expiry date will remove an
       account expiration date.

*** Strong password
    Force users to set strong passwords using *Pluggable
    Authentication Modules (PAM)*. *PAM* can be configured to
    automatically verify that a password created or modified using the
    *passwd* utility is sufficiently strong. *PAM* configuration is
    implemented using a library called *pam_cracklib.so*, which can
    also be replaced by *pam_passwdqc.so* for more options.

** Securing the boot process and hardware resources
   You can secure the boot process with a secure password to prevent
   someone from bypassing the user authentication step. For systems
   using the GRUB boot loader, for the older GRUB version 1, you can
   invoke *grub-md5-crypt* which will prompt you for a password and
   then encrypt.

   You must then edit =/etc/grub/grub.cfg= file by adding the
   following line below the timeout entry:
   #+BEGIN_EXAMPLE
   password --md5 <encrypted-password>
   #+END_EXAMPLE
   
   You can also force passwords for only certain boot choices rather
   than all.

   You never edit the configuration file, =/boot/grub/grub.cfg=
   directly, rather you edit system configuration files in
   =/etc/grub.d= and then run =update-grub=.

   - refer :: https://help.ubuntu.com/community/Grub2/Passwords

** Hardware Vulnerability
   When hardware is physically accessible, security can be compromised
   by:
*** Key Logging
    Recording the real time activity of a computer used including the
    keys they press. The captured data can either be stored locally or
    transmitted to remote machines.

*** Network sniffing
    Capturing and viewing the network packet level data on your
    network.

*** Live CD
    Booting with a live cd or rescue disk.

*** Remounting and modifying disk content

** Security Policy
   IT security policy should start with requirements on how to
   properly secure physical access to servers and
   workstations. Physical access to a system makes it possible for
   attackers to easily leverage several attack vectors, in a way that
   makes all operating system level recommendations irrelevant.

   The guidelines for security are:

   1. Lock down workstations and servers.
   2. Protect your network link such that it can not be accessed by
      people you do not trust.
   3. Protect your keyboards where passwords are entered to ensure the
      keyboards cannot be tampered with.
   4. Ensure a password protects the BIOS in such a way that system
      cannot be booted with a live or rescue DVD or USB key.

* Network Operations
  A network is a group of computers connected together via a
  communication channels such as cable or wireless.

  Network is used to share devices such as printers and scanners among
  various users. It is also used to share and manage information
  across computers easily.

  Most organizations have both internal network and an internet
  connection for users to communicate with machines and people outside
  the organization. The internet is the largest network in the world
  and is often called the "network of networks".

** IP Address
   Machine connected to the network must have at least one unique
   network address identifier known as the IP (Internet Protocol)
   address. The address is essential for routing packets of
   information through network.

   Packets contains data buffers together with headers which contain
   information about where the packet is going to and coming from, and
   where it fits in the sequence of packets that constitute the
   stream.

   Networking protocols and software are rather complicated due to the
   diversity of machines and operating systems they must deal with, as
   well as the fact that even old standards must be supported.

*** IPv4
    It uses 32-bits for addresses; there are only 2^32 = 4.3 billion
    unique addresses available.
    #+BEGIN_EXAMPLE
    10.4.1.12
    #+END_EXAMPLE

**** IPv4 classes
     IPv4 address consists of four 8-bits sections called octets.
     Network addresses are divided into five classes: A, B, C, D and
     E. Class A, B and C are classified into two parts: *Network
     address (Net ID) and Host address (Host ID)*. The Net ID is used
     to identify the network, while the Host ID is used to identify a
     host in the network. Class D is used for special multicast
     applications and class E is reserved for future/research use.

***** Class A address
      Class A ip addresses use first octet as the Network ID and use
      the other three octets as the Host ID. The first bit of the
      first octet is always set to =0=. So you can use only 7-bits for
      unique network numbers. As a result we can use maximum of 126
      class A networks available (the addresses 0000000 and 1111111
      are reserved). This was only useful when there were few networks
      with large number of hosts.

      Each class A network can have up to 16.7 million unique hosts on
      its network. The range of host address is from 1.0.0.0 to
      127.255.255.255.

***** Class B address
      Class B address use the first two octets of the IP address as
      their Net ID and the last two octets as the Host ID. The first
      two bits of the first octet are always set to binary =10=, so
      there are a maximum of (14-bits) class B networks. The first
      octet of a class B address has values from 128 to 191.

      Each class B network can support a maximum of 65,536 unique
      hosts on its network. The range of host address is from
      128.0.0.0 to 191.255.255.255.

***** Class C address
      Class C address use the first three octets of the IP address as
      their Net ID and the last octet as their Host ID. The first
      three bits of the first octet are set to binary =110=. The first
      octet of a class C address has values from 192 to 223. These are
      most common for smaller networks which don't have many unique
      hosts.

      Each class C network can support up to 256 (8-bit) unique
      hosts. The range of hosts address is from 192.0.0.0 to
      223.255.255.255.

*** IPv6
    It uses 128-bits for addresses; this allows for 3.4 * 10^38
    addresses. It is difficult to move to IPv6 as the two protocols do
    not inter-operate.
    #+BEGIN_EXAMPLE
    2001:0db8:0a0b:12f0:0000:0000:0000:0001
    #+END_EXAMPLE

** IP Address allocation
   A range of IP addresses are requested from Internet Service
   Provider (ISP) by an organization's network administrator. Often
   the choice of which class of IP address given depends on the size
   of network and expected growth needs.

   We can assign IP address to computers over a network manually or
   dynamically. When we assign IP addresses manually, we add *static*
   (never changing) addresses to the network. When we assign IP
   addresses dynamically (they can change every time you reboot or
   even more often), the *Dynamic Host Configuration Protocol* (DHCP)
   is used to assign IP addresses.

*** Manually allocating an IP address
    Before an ip address can be allocated manually, one must identify
    the size of the network by determining the host range; this
    determines which network class (A, B, or C) can be used. The
    *ipcalc* program can be used to ascertain the host range.
    #+BEGIN_EXAMPLE
    $ ipcalc 192.168.0.0/24
    Address:   192.168.0.0          11000000.10101000.00000000. 00000000
    Netmask:   255.255.255.0 = 24   11111111.11111111.11111111. 00000000
    Wildcard:  0.0.0.255            00000000.00000000.00000000. 11111111
    =>
    Network:   192.168.0.0/24       11000000.10101000.00000000. 00000000
    HostMin:   192.168.0.1          11000000.10101000.00000000. 00000001
    HostMax:   192.168.0.254        11000000.10101000.00000000. 11111110
    Broadcast: 192.168.0.255        11000000.10101000.00000000. 11111111
    Hosts/Net: 254                   Class C, Private Internet
    #+END_EXAMPLE

** Network Interfaces
   

* COMMENT TODO
  - Proposed plan to do this course is to spend daily one hour
    attending classes.
  - Revise ch-3 boot process again at the end of the course.
  - Learn why Linux is virus secured. Are there any anti-virus systems
    for Linux. refer [[Process Isolation]]
  - Read about National Security Agency. 
  - Revise nfs.
  - Revise apt-get.
  - Try out boot loader password.

* Useful links
  - http://linuxcommand.org/tlcl.php (resource for commands help)
  - https://www.centos.org/docs/ (centos documentaion)
  - http://refspecs.linuxfoundation.org/fhs.shtml (file system)
  -
    https://courses.edx.org/asset-v1:LinuxFoundationX+LFS101x+1T2016+type@asset+block/LFS101_Ch3_Sec1_FSH.pdf
   (filesystem)
  - http://www.pathname.com/fhs/pub/fhs-2.3.pdf (Filesystem hierarchy
    standard
