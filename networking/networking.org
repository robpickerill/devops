#+Title: Introduction to Computer Networks
#+Author: Yogesh Agrawal
#+Email: yogeshiiith@gmail.com
#+Date: <2016-07-31 Sun>

* Introduction
  This document discusses about the computer networking concepts
  learnt from Netorking-SP course in [[https://lagunita.stanford.edu/courses/Engineering/Networking-SP/SelfPaced/courseware][edx.org]].

* Connectivity
  Connectivity is the idea that two computers in different parts of
  the world can connect to one another and exchange data. If we
  connect our computer to the internet we suddenly can talk with all
  the other computers connected on the internet.
* Network Applications
  Read and write data over network. Dominant model: bidirectional,
  reliable byte stream connection.
  - One side reads what the other writes
  - Operates in both directions
  - Reliable (unless connection breaks)

  The basic model is: there are two computers each running a program
  locally, and these two programs communicate over the network. The
  most common communication model used is a bidirectional, reliable
  stream of bytes.

* Byte Stream model
  Computer B is waiting for other computers to connect to it. Computer
  A wants to communicate to B. A and B set up a connection. Now when A
  writes data to the connection, B can read it and when B writes data
  to the connection, A can read it. Either side can close the
  connection. Computer A(client) can close the connection, or computer
  B(server) can also close the connection. The error message
  "connection reset by peer", means the server closed the connection
  when client was not expecting it. Server can refuse the connection
  as well, or have a browser wait for a long time because the server
  isn't even responding with a refusal.

* World Wide Web(HTTP)
  The world wide web works using HTTP, which stands for HyperText
  Transfer Protocol.

  In HTTP a client opens a connection to a server and sends commands
  to it. Server after receiving the request checks if client is
  authorized to access the resource, and then sends a response. The
  response also contains a numeric code. There are various types of
  commands such as GET, PUT, DELETE, INFO, as well as other responses
  such as 400 Bad Request. HTTP is all in ASCII text: for example, the
  beginning of a GET request looks like:
  #+BEGIN_EXAMPLE
  GET / HTTP/1.1
  #+END_EXAMPLE
  and the beginning of a response to a successful requests looks like:
  #+BEGIN_EXAMPLE
  HTTP/1.1 200 OK
  #+END_EXAMPLE

  The basic model is simple: client sends a requests by writing to the
  connection, the server reads the request, processes it, and writes a
  response to the connection, which the client then reads.
* Skype
  Unlike the web, where there is a client and a server, in Skype case
  we have two clients. So rather than having a personal computer
  requesting for data from a dedicated server, we have two personal
  computers requesting data from each other. This difference turns out
  to have really big implication to how Skype works.

  The complication comes from NAT, or Network Address
  Translation. NATs are everywhere today. A small home wireless router
  is a NAT. When a mobile phone connects to the internet, it is behind
  a NAT. If a computer is behind NAT, then it can open a connection to
  the internet, but other nodes on the internet can't easily open
  connections to that computer.
  
  Consider a scenario: Client B is behind NAT, Client A is not behind
  NAT. Now client A wants to talk to client B. The complication here
  is that client A, can't open a connection to client B, as it is
  behind NAT. Skype uses Rendezvous server to allow communication in
  such scenario. When we login to Skype, client opens a connection to
  a network of control servers. In this case, client B opens a
  connection to the Rendezvous server. 

  When client A wants to communicate with client B, it tries to
  connect to client B, but it could not. So instead it sends a message
  to a computer to which client B, is already connected to. Which then
  tells client B, that there is a call from A. If client B accepts the
  call, then it opens a connection to client A. Since client A isn't
  behind NAT, this connection can open normally. This is called
  reverse connection, as it reverses the expected direction of
  initiating the connection. when the connection gets established they
  exchange data over that channel.

  When both the clients A and B are behind NATs, we can't reverse the
  connection. Client A can not open connection to client B and client
  B can not open connection to client A. To handle this case Skype
  introduces a second kind of server, called a relay. Relay can't be
  behind NATs. If both client A and client B are behind NATs, then
  they communicate through relay server. They both open connections to
  the relay. When client A sends data, the relay forwards it to client
  B through the connection that B opened. When client B sends data,
  the relay forwards it to client A through the connection that A
  opened.

  A very simple abstraction - a bidirectional and reliable data
  stream, can be used in many interesting ways. By changing how
  programs open connections and what different programs do, we can
  create complex applications.

* Internet 4-layer model
  Applications want to send and receive data without having to worry
  about the path, or route that data takes across the internet. And
  almost all applications also need to be confident that data is
  delivered correctly, with any lost or corrupted data automatically
  retransmitted until is received correctly.

  Four layers are as follows:
  1. Application layer
  2. Transport layer
  3. Network layer
  4. Link layer

  Early internet pioneers designed this four layer model to describe
  the hierarchy of operations that make up the internet, so that
  applications can reuse the same building blocks over and over again
  instead of creating them from scratch for every application.

  It helps to remember that all 4 layers are there to enable reliable
  communication between end-hosts applications. Each layer has a
  different responsibility of building a service on top of the one
  below, all the way to the top where we have bidirectional, reliable
  byte stream communication between applications.

** Link Layer
   Its job is to carry data one link at a time. Data is delivered
   hop-by-hop over each link in turn. Delivers data over a single link
   between an end host and router, or between routers. Ethernet and
   wifi are two examples of link layer. Data is delivered in
   packets. Packet is a self contained unit which contains data to be
   delivered and headers such as - where it came from, where it is
   going and so on.

** Network Layer
   Network layer packets are called datagrams. The network layer hands
   the datagram to the Link layer below, telling it to send the
   datagram over the first link. At the other end of the link is a
   router. The Link layer of the router accepts the datagram and hands
   it up to the network layer. Network layer examines the destination
   address of the datagram, and is responsible for routing the
   datagram one hop at a time, towards its eventual destination. It
   does this by sending it to the Link layer again, and so on until it
   reaches the Network layer at the destination.

   Network layer does not need to concern itself, how link layer
   transmits the data. This also means that single network layer has a
   common way to talk to many different link layers by simply handing
   over the datagrams. 

   This separation of concerns is made possible by the modularity of
   each layer and a common well-define API to the layer below.

   When we send packets to internet we must use Internet Protocol
   (IP). Which provides following features:
   1. Makes best-effort attempt to deliver datagrams to the other end,
      but no promises.
   2. Datagrams may get delivered out of order, may get corrupted, it
      does not provide any guarantees.

** Transport Layer
   If an application wants a guarantee that its data will be
   retransmitted when lost, and will be delivered in order and without
   corruption, then it needs to use another protocol called *Transfer
   Control Protocol (TCP)*, running on top of IP.

   TCP/IP applications uses both TCP and IP together.

   TCP provides a service to application which guarantees correct
   in-order delivery of data, running on top of network layer service,
   which provides an unreliable datagram delivery service. If the
   network layer drops some datagrams, TCP will retransmit them
   multiple times if needed. If the network layer delivers them out of
   order - perhaps because packets follow different path to reach
   destination, TCP will put the data back into the right order again.

   Example of application which uses TCP is email client. These
   applications employ TCP for correct delivery of data. Applications
   don't have to implement their own mechanism for this. They can
   reuse the TCP service, developed by other developers.

   Some applications don't need TCP service. Example: If a video
   streaming application sending a video snippet in a packet, then
   there is no point waiting for packet to be retransmitted multiple
   times, better to just move on. Such applications can use much
   simpler *User Datagram Protocol (UDP)*. UDP bundles application
   data and hands it over to network layer for delivery. UDP offers no
   delivery guarantees.
   
** Application Layer
   While each application is different, it can reuse the Transport
   Layer service using the well-defined API from the application layer
   to the TCP/UDP service beneath.

   Application protocol uses their own syntax and semantics to
   represent data. For example when application requests a page from a
   web server, it sends a GET request to the server. HTTP dictates
   that the GET command be sent as ASCII text. As far as application
   layer is concerned, it send data directly to the application layer
   of the server. Application layer does not need to worry about how
   the data got there, which routes it followed, was there any
   retransmission etc.

* IP
  IP is considered to be a thin waist. If we want to use internet we
  have to use IP, there is no choice. IP can be used with many
  different link layers such as wifi, ethernet, 3G etc. On top of IP,
  there can be many different transport layers such as TCP, UDP, RTP
  etc. Similarly it can also be used with many different application
  layers such as HTTP, SSH, FTP, SMTP etc.

  IP datagrams consist of a header and some data. When the transport
  layers has data to send, it hands a Transport Segment to the network
  layer below. The network layer puts the transport segment inside a
  new IP datagram with some header fields. IP's job is to deliver the
  datagram to the other end. But first, it has to make its way to the
  first link to the first router. For this it hands the IP datagram to
  the link layer. Link layer puts the IP datagram inside a Link Frame,
  such as Ethernet packet and ships it off to the first router.
  
* COMMENT TODO
  1. join emacs group
  2. Understanding the Linux Kernel
  3. Check if we can make two concurrent calls in skype to a user.
  4. Skype works on which port?
